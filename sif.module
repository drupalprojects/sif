<?php

/**
 * @file sif.module
 * Main module file for SIF Integration
 */


/**
 * Implements hook_permission().
 */
function sif_permission() {
  $permissions = array(
    'configure sif' => array(
      'title' => t('Configure SIF'),
      'description' => t('Allows users to configure SIF server settings.'),
      'restrict access' => TRUE,
    ),
  );

  return $permissions;
}

/**
 * Helper for generating our application key.
 */
function sif_get_application_key($token = NULL) {
  $type = variable_get('sif_server_auth_type', 'secret');
  if ($type == 'secret') {
    if (!$token) {
      if (!$env_id = variable_get('sif_default_environment_id')) {
        $token = variable_get('sif_server_auth_token', 'new');
      }
    }
    if (!$token && $env_id) {
      $entities = entity_load('sif_data_object', array($env_id));
      if (isset($entities[$env_id])) {
        $token = $entities[$env_id]->sessionToken;
      }
      else {
        $token = variable_get('sif_server_auth_token', 'new');
      }
    }
    $secret = variable_get('sif_server_auth_secret', 'guest');
    return "Basic " . base64_encode($token . ':' . $secret);
  }
  else if ($type == 'token') {
    if ($token = variable_get('sif_server_auth_token', NULL)) {
      $token = sif_decrypt($token);
    }
    return $token;
  }
}

/**
 * Helper for encrypting/decrypting data
 */
function sif_encrypt($data) {
  $key = pack('H*', $drupal_hash_salt);
  $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
  $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
  $ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $data, MCRYPT_MODE_CBC, $iv);
  $ciphertext = $iv . $ciphertext;
  $ciphertext_base64 = base64_encode($ciphertext);
  return $ciphertext_base64;
}

/**
 * Helper for decrypting data
 */
function sif_decrypt($data) {
  $key = pack('H*', $drupal_hash_salt);
  $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
  $ciphertext = base64_decode($data);
  $iv = substr($ciphertext, 0, $iv_size);
  $ciphertext = substr($ciphertext, $iv_size);
  $plaintext = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $ciphertext, MCRYPT_MODE_CBC, $iv);
  return $plaintext;
}

/**
 * Helper to get human readable XML
 */
function clean_xml($xml, $html_encode = FALSE) {
  $simple_xml = new SimpleXMLElement($xml);
  $dom = dom_import_simplexml($simple_xml)->ownerDocument;
  $dom->formatOutput = TRUE;
  $output = $dom->saveXML();
  if ($html_encode) {
    return '<pre>' . htmlspecialchars($output) . '</pre>';
  }
  else {
    return $output;
  }
}

/**
 * Helper to create GUIDs
 * @return string
 *   A randomly generated GUID
 */
function sif_guid() {
  if (function_exists('com_create_guid')) {
    return trim(com_create_guid(), '{}');
  }
  return sprintf('%04X%04X-%04X-%04X-%04X-%04X%04X%04X', mt_rand(0, 65535), mt_rand(0, 65535), mt_rand(0, 65535), mt_rand(16384, 20479), mt_rand(32768, 49151), mt_rand(0, 65535), mt_rand(0, 65535), mt_rand(0, 65535));
}

/**
 * Generic function to GET a SIF object
 * @param  string $type
 *   Object type we are querying.
 * @param  array $path_args
 *   Arguments to be put in the SIF request URL. Possible values are:
 *     - zoneId - The zone to be queried in
 *     - deleteMessageId - The message to delete from the queue
 *     - page - Which page to query
 *     - pageSize - How many results per page
 *     - path - Any additional path
 *     - id - The refId being queried
 *     - multi - If this is a query for multiple items
 *     - queryIntention - UNDEFINED or QUERYING_ALL_PAGES
 * @param  string $environment
 *   The environment to query within (uses default otherwise).
 * @return mixed          
 *   False on error or no more messages in queue. TRUE or data on success.
 */
function sif_get($type, $path_args = array(), $environment = NULL) {
  $request = new sifRequest('GET', $type, $path_args, $environment);
  
  if ($request->paged) {
    if (!$request->paged_active) {
      drupal_set_message(t('No more pages available.'));
      return FALSE;
    }
  }

  $two_oh_four_error = FALSE;
  if ($type == 'queue' || $request->paged) {
    $two_oh_four_error = TRUE;
  }

  if ($request->environment) {
    $response = $request->sif_request();

    if (sif_error_check($response, 'GET', $two_oh_four_error)) {
      return FALSE;
    }
    else {
      if (property_exists($response, 'data')) {
        if ($response->data) {
          return $response;
        }
      }
      if (property_exists($response, 'headers')) {
        if ($response->headers['navigationId']) {
          $nav_info['timestamp'] = time();
          $nav_info['navigation_id'] = $response->headers['navigationId'];
          if ($response->headers['navigationLastPage']) {
            $nav_info['navigation_last_page'] = $response->headers['navigationLastPage'];
          }
          if ($response->headers['navigationPage']) {
            $nav_info['navigation_page'] = $response->headers['navigationPage'];
          }
          variable_set("sif_nav_$request->query_stamp", $nav_info);
        }
      }
      return TRUE;
    }
  }
  else {
    drupal_set_message(t('No environment selected. Either explicitly call an environment, or set a default.'));
    return FALSE;
  }
}

/**
 * Generic function to POST a SIF object
 * @param  string $type
 *   Object type we are querying.
 * @param  string $xml
 *   The XML for the query.
 * @param  array $path_args
 *   Arguments to be put in the SIF request URL. Possible values are:
 *     - zoneId - The zone to be queried in
 *     - deleteMessageId - The message to delete from the queue
 *     - page - Which page to query
 *     - pageSize - How many results per page
 *     - path - Any additional path
 *     - id - The refId being queried
 *     - multi - If this is a query for multiple items
 *     - queryIntention - UNDEFINED or QUERYING_ALL_PAGES
 * * @param  string $environment
 *   The environment to query within (uses default otherwise).
 * @return mixed
 *   False on error or no more messages in queue. TRUE or data on success.
 */
function sif_post($type, $xml = NULL, $path_args = array(), $environment = NULL) {
  if ($type == 'environment') {
    $environment = 'new';
  }

  $request = new sifRequest('POST', $type, $path_args, $environment);

  if ($request->environment) {
    $response = $request->sif_request($xml);

    if (sif_error_check($response, 'POST')) {
      return FALSE;
    }
    else {
      if (property_exists($response, 'data')) {
        if ($response->data) {
          return $response;
        }
      }
      return TRUE;
    }
  }
  else {
    drupal_set_message(t('No environment selected. Either explicitly call an environment, or set a default.'));
    return FALSE;
  }
}

/**
 * Generic function to PUT a SIF object
 * @param  string $type
 *   Object type we are querying.
 * @param  string $xml
 *   The XML for the query.
 * @param  array $path_args
 *   Arguments to be put in the SIF request URL. Possible values are:
 *     - zoneId - The zone to be queried in
 *     - deleteMessageId - The message to delete from the queue
 *     - page - Which page to query
 *     - pageSize - How many results per page
 *     - path - Any additional path
 *     - id - The refId being queried
 *     - multi - If this is a query for multiple items
 *     - queryIntention - UNDEFINED or QUERYING_ALL_PAGES
 * @param  string $environment
 *   The environment to query within (uses default otherwise).
 * @return mixed
 *   False on error or no more messages in queue. TRUE or data on success.
 */
function sif_put($type, $xml, $path_args = array(), $environment = NULL) {
  $request = new sifRequest('PUT', $type, $path_args, $environment);

  if ($request->environment) {
    $response = $request->sif_request($xml);

    if (sif_error_check($response, 'PUT')) {
      return FALSE;
    }
    else {
      if (property_exists($response, 'data')) {
        if ($response->data) {
          return $response;
        }
      }
      return TRUE;
    }
  }
  else {
    drupal_set_message(t('No environment selected. Either explicitly call an environment, or set a default.'));
    return FALSE;
  }
}

/**
 * Generic function to DELETE a SIF object
 * @param  string $type
 *   Object type we are querying.
 * @param  string $xml
 *   The XML for the query.
 * @param  array $path_args
 *   Arguments to be put in the SIF request URL. Possible values are:
 *     - zoneId - The zone to be queried in
 *     - deleteMessageId - The message to delete from the queue
 *     - page - Which page to query
 *     - pageSize - How many results per page
 *     - path - Any additional path
 *     - id - The refId being queried
 *     - multi - If this is a query for multiple items
 *     - queryIntention - UNDEFINED or QUERYING_ALL_PAGES
 * @param  string $environment
 *   The environment to query within (uses default otherwise).
 * @return mixed
 *   False on error or no more messages in queue. TRUE or data on success.
 */
function sif_delete($type, $xml = NULL, $path_args = array(), $environment = NULL) {
  $request = new sifRequest('DELETE', $type, $path_args, $environment);

  if ($request->environment) {
    $response = $request->sif_request($xml);

    if (sif_error_check($response, 'DELETE')) {
      return FALSE;
    }
    else {
      if (property_exists($response, 'data')) {
        if ($response->data) {
          return $response;
        }
      }
      return TRUE;
    }
  }
  else {
    drupal_set_message(t('No environment selected. Either explicitly call an environment, or set a default.'));
    return FALSE;
  }
}

/**
 * Store a SIF data object as an entity
 * @param  string $type
 *   Type of data object
 * @param  string $xml
 *   The XML representing the object
 * @param array $headers
 *   The headers from the request
 * @return boolean
 *   True on success, false on failure
 */
function sif_store($type, $xml, $headers) {
  $xml_object = new SimpleXMLElement($xml);
  if (!$id = (string) $xml_object->attributes()->id) {
    $id = (string) $xml_object->attributes()->refId;
  }
  $values = array(
    'id' => $id,
    'type' => $type,
    'xml' => $xml,
    'headers' => serialize($headers),
  );
  $entity = entity_create('sif_data_object', $values);
  if (entity_save('sif_data_object', $entity)) {
    module_invoke_all('sif_after_store', $type, $id);
    drupal_set_message(t('SIF %type object was saved.', array('%type' => $entity->type)));
    return TRUE;
  }
  else {
    drupal_set_message(t('Entity not created! Something went wrong.'), 'error');
    return FALSE;
  }
}

/**
 * Delete a SIF data object stored as an entity
 * @param  string $type
 *   The type of object
 * @param  string $id
 *   The id of the object
 * @return boolean
 *   True on success, false on failure
 */
function sif_local_delete($type, $id) {
  $args = array(
    '@type' => $type,
    '%title' => $id,
  );
  entity_delete('sif_data_object', $id);
  if (!sif_load($id)) {
    // Report back success.
    watchdog('sif', 'SIF @type %title has been deleted from the local database.', $args);
    drupal_set_message(t('SIF @type %title has been deleted from the local database.', $args));
    return TRUE;
  }
  else {
    watchdog('sif', 'SIF @type %title has NOT been deleted from the local database.', $args, WATCHDOG_ERROR);
    drupal_set_message(t('SIF @type %title has NOT been deleted from the local database.', $args), 'error');
    return FALSE;
  }
}

/**
 * Loads a SIF data object
 * @param  string $id
 *   ID of the object
 * @return mixed
 *   Object on success, false on failure
 */
function sif_load($id) {
  $entities = entity_load('sif_data_object', array($id));
  if (isset($entities[$id])) {
    return $entities[$id];
  }
  else {
    return FALSE;
  }
}

/**
 * Checks the error code for a correct error message
 * @param  string $response
 *   Response object
 * @param  string $type
 *   Type of request
 * @param bool $two_oh_four_error
 *   Whether a 204 response should be considered an error or not
 * @return mixed
 *   The error associated with that code or false on an OK
 */
function sif_error_check(&$response, $type, $two_oh_four_error = FALSE) {
  $statuses = array(
    '200' => 'OK',
    '201' => 'OK',
    '204' => 'OK',
  );

  if ($two_oh_four_error && $response->code == '204') { // TODO: get rid of this cludginess
    return TRUE;
  }
  else {
    if (isset($statuses[$response->code])) {
      return FALSE;
    }
    else {
      $error = $response->error;

      if (property_exists($response, 'data')) {
        drupal_set_message(t('@type unsuccessful: @message', array('@type' => $type, '@message' => strip_tags($response->data))));
      }
      else {
        drupal_set_message(t('@type unsuccessful: code: @code, error: @error', array('@type' => $type, '@code' => strip_tags($response->code), '@error' => $error)));
      }
      
      return $error;
    }
  }
}

/**
 * logs requests to watchdog if this setting is turned on
 * @param  array  $options
 *   The options sent to drupal_http_request
 * @param  object $response
 *   The response object         
 */
function sif_log($options, &$response) {
  $log_setting = variable_get('sif_connection_logging');
  if ($log_setting && module_exists('devel')) {
    $args = array();

    $args['!options'] = dpr($options, TRUE);
    if (property_exists($response, 'data')) {
      if ($response->data) {
        $args['!data'] = clean_xml($response->data, TRUE);
      }
    }
    if (property_exists($response, 'request')) {
      $args['!request'] = dpr($response->request, TRUE);
    }
    if (property_exists($response, 'code')) {
      $args['@code'] = $response->code;
    }
    if (property_exists($response, 'headers')) {
      $args['!headers'] = dpr($response->headers, TRUE);
    }
    if (property_exists($response, 'error')) {
      $args['!error'] = dpr($response->error, TRUE);
    }
    watchdog('sif', 'Request made. Returned code - @code<br/>
      ---- Options ---- !options<br/>
      ---- Request ---- !request<br/>
      ---- Headers ---- !headers<br/>
      ---- Data ---- !data<br/>
      ---- Error ---- !error', $args);
  }
}
